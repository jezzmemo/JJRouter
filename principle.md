# Business Architeture

## 为什么要组件化，业务组件

* 提高开发效率，独立编译业务模块
* 团队协同，每个团队关注自己的领域，聚焦，减少冲突
* 复用，减少重复劳动
* 架构清晰，分工明确，横向扩展能力


## Business and Module difference(业务模块和基础模块的不同)

- 业务模块分离了头部分和实现部分，头和实现部分单向依赖，只能实现部分依赖头，头不能依赖实现，基础模块直接对外
- 层次不一样，业务需要解决特定的业务，基础模块是业务不敏感
- 业务模块是可以上下，横向依赖的，基础模块只有上下依赖
- 业务模块需要有横向的能力，所以要解决业务模块相互引用的问题，而基础模块是不行的，在工程上编译期间就会不通过
- 工程组织方式不一样，业务模块需要将头和实现分开，工程上是两个模块，基础模块直接是一个模块

## 业务组件的层次位置

### Feature Business Layer

这个层次基本就是具体的实现，承载具体的业务，直接可以继承到具体的App上，业务模块的职责很清晰，完成产品指定的业务功能

### Infra Business Layer

Infra Business Layer比Business Layer比下面一层，因为他们之间是上下关系，不是横向关系，他作为基础的业务组件，会被很多上层的业务组件依赖，业务领域来说，他可能是一个或者多个领域的基础业务组件，这个的话跟具体的业务场景来决定

## 业务组件架构图（Done)

### 为什么业务模块要分离头和实现

* 业务模块一般实现比较重，头的方式比较轻，API申明简单，明确，开发者接入简单
* 从设计上来看，解耦，API公开和实现彻底分开，输入和输出更加明确
* 基于接口设计，扩展性更好
* 解决同一层次循环引用问题

### 补充头和实现分离的架构图（Done)

> 头部含有的信息

* Notification的定义
* 具体的业务接口定义

> 实现部分包含哪些

* 接口定义的实现
* 事件和通知的实现
* 其他内部不需要对外的实现

## ModuleAgent(组件中间者)

**OC和Swift**区别，所以在实现中间者上的差异比较大，语言特性决定的

- 唯一的ModuleAgent来进行统一调用
- 组件各自定义，基于统一协议即可，对外API，直接定义直观的in和out，对开发者比较友好
- Swift使用Extension方式来实现中间者调用
- 支持Scheme,作为option的方式

## 组件模板创建和维护

> git clone cocopoads template

下载到本地，将cocoapods的模板上传到公司内网，并做适当的修改，可作为业务模块的模板保存，如果有其他领域或者特色业务，也可以这样操作

> 创建模板脚本(Ruby)

- 脚本通过pod lib create `ModuleName`
- 新增ModuleNameHeader.podspec到Meta文件夹
- 新增和classes同级的ModuleNameHeaderClasses和示例文件

## 如何发布组件
